package MooseX::StateMachine::Meta::Machine::Partial;
# ABSTRACT: a partially-built state machine
use Moose;
use true;
use namespace::autoclean;

has 'base' => (
    is       => 'ro',
    isa      => 'Moose::Meta::Class',
    required => 1,
    handles  => ['name'],
);

has 'state_definitions' => (
    is       => 'ro',
    isa      => 'HashRef[HashRef]', # Name -> Definition
    traits   => ['Hash'],
    default  => sub { +{} },
    handles  => {
        states               => 'keys',
        has_state            => 'exists',
        definition_for_state => 'get',
        add_state_definition => 'set',
    },
);

before add_state_definition => sub {
    my ($self, $name) = @_;

    # yes, very arbitrary, but why make everyone suffer when typing
    # the API role name just because some crazy person wants every
    # valid perl identifier for a state name
    # -JR

    confess 'cannot name a state API' if
        uc $name eq 'API';
};

has 'start_state' => (
    is        => 'rw',
    isa       => 'Str',
    predicate => 'has_start_state',
);

has 'transitions' => (
    init_arg => 'transitions',
    isa      => 'ArrayRef[Str]',
    traits   => ['Array'],
    default  => sub { +[] },
    handles  => {
        add_transition => 'push',
        transitions    => 'elements',
    },
);

has 'api_role' => (
    is         => 'ro',
    isa        => 'Moose::Meta::Role',
    lazy_build => 1,
);

sub _build_api_role {
    my $self = shift;

    my $name = $self->name. '::API';

    Moose::Meta::Role->create($name);

    my $role = $name->meta;

    # is_* for all states
    $role->add_required_methods(
        map { "is_$_" } $self->states,
    );

    return $role;
}

sub build_class_for {
    my ($self, $state, $def) = @_;

    my $name = $self->name."::\u$state";

    Moose::Meta::Class->create(
        $name,
        authority    => 'Autogenerated by MooseX::StateMachine',
        version      => $MooseX::StateMachine::VERSION,
        superclasses => [$self->name],
    );

    Moose::Util::MetaRole::apply_metaroles(
        for             => $name,
        class_metaroles => {
            class => ['MooseX::StateMachine::Meta::Class::State'],
        },
    );

    Moose::Util::MetaRole::apply_base_class_roles(
        for   => $name,
        roles => ['MooseX::StateMachine::Role::Base'],
    );

    my $meta = $name->meta;

    # set some attributes in the metaclass
    $meta->state_name($state);
    $meta->base(my $base = $self->base);

    # add the is_* for all states
    $meta->add_method( "is_$state" => sub { 1 } );
    for my $s ($self->states) {
        next if $s eq $state;
        $meta->add_method( "is_$s" => sub { 0 } );
    }

    # apply the common state role
    $self->api_role->apply($meta);

    # add the method to do each transition
    my %transitions = %{ $def->{transitions} || {} };
    $meta->set_transitions( [ keys %transitions ] );

    for my $t (keys %transitions) {
        my $code = $transitions{$t};

        $meta->add_method( $t => sub {
            my $self = shift;
            $code->($self, @_);
            $base->rebless_instance_back($self);

            my $new_class = $self->meta->class_for_state($t);
            $new_class->rebless_instance($self);
            return; # XXX: should this return $code->()'s return ?
        });
    }

    # add the requested methods
    my %methods = %{ $def->{methods} || {} };
    for my $m (keys %methods) {
        my $code = $methods{$m};
        $meta->add_method( $m => $code );
    }

    return $meta;
}

sub build_state_machine {
    my ($self, $class) = @_;
    $class ||= 'MooseX::StateMachine::Meta::Machine';

    my @states = map {
        $self->build_class_for( $_, $self->definition_for_state($_) );
    } $self->states;

    $class->new(
        base        => $self->base,
        start_state => $self->start_state,
        states      => \@states,
        transitions => [$self->transitions],
    );

}


__PACKAGE__->meta->make_immutable;
